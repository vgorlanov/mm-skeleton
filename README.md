## Module monolith

Демонстрационный пример реализации маркет-плейса в виде модульного монолита.

## Общая теория
Существуют разные подходы к структуризации кода в монолите. Наиболее часто выделяют 3:
- **Package-by-type** - структуризация по типу. Пример: базовая структура фреймворка, 
    где команды лежат в директории Commands, формы в Forms и т.д. Т.е. группируются по типам
- **Package-by-layer** - структурирование по слоям. Структура по слоям (слоённая архитектура, DDD-lite)
- **Package-by-feature** - структурирование по фичам (модульность, пакеты и т. д.)

[Как структурировать код, чтобы не получить большой ком грязи](https://youtu.be/SycSx0Qp3eg?t=3910)

## Преимущества Package-by-feature
- Высокое зацепление (High cohesion)
- Низкая связанность (low coupling)
- Уменьшение конфликтов при слиянии git merge
- Простота распиливания монолита на сервисы
- Управление сложностью - каждый модуль может быть реализован как угодно
- Более простая документация проекта
- Более простой код-ревью (есть понимание на что обращать внимание при ревью)

## Общая структура:
- Common - Общий код используемы в различных модулях.
- Gateway - Основная точка входа (внешнее API), содержит преимущественно контроллеры, вызывает API моделуй.
- Modules - Директория с модулями.

## Структура Модуля:
Жёстких требований к структуре модуля нет. Каждый модуль может быть реализован наиболее оптимальным способом исходя из его предназначения.
В данном примере все модули реализованны в виде слоёной архитектуры.

- API - внешний api модуля. 
- Domain - Бизнес логика модуля.
- Infrastructure - Инфраструктурный слой модуля.
- Providers - ServiceProvider-ы модуля, для регистрации репозиториев, API и т.д.

### API (Директория в модуле) 
Все действия с модулем должны осуществляться через контракты находящиеся в этой директории. 
Даже если одному модулю понадобятся данные из другого. Получение этих данных должно происходить из соответствующего API первого модуля (если такое api есть).
Прямой экспорт классов из модуля запрещён. Контроль зависимостей можно осуществлять с помощью пакета [Deptrac](https://github.com/qossmic/deptrac).
Реализация данного модульного монолита позволяет выносить модули в отдельные сервисы. 

### Вынесение модуля в отдельный сервис.
В директории API каждого модуля находятся поддиректории являющиеся конкретными api (создание, удаления, получение и т.д.).
В каждой поддиректории находится PHP Interface описывающий контракт для этого api. И класс Module реализующий этот интерфейс.
Что бы вынести модуль в отдельный сервис, необходим реализовать новый класс осуществляющий взаимодействие с этим сервисом (http, grpc и т.д.).
И в ServiceProvider-e забиндить новый класс к этому интерфейсу.  

## DB
Прямой вызов классов одного модуля запрещён в другом модуле. Это же относится и к бд. Таблицы принадлежащие к одному модулю должны быть использованы
в другом. Для этого можно либо использовать разные бд для каждого модуля. Либо для имён таблиц модуля, создавать префиксы (Например product_tablename, order_tablename и т. д.)

## "Общение модулей"
Помимо API модулей имеется возможность посылать события в брокер сообщений (в данном примере используется RabbitMQ). Когда происходит событие, например
UserCreated, в сервисном слое отправляется информация о новом пользователе в брокер. И заинтересованные модули могут быть подписаны на это сообщение.
Например, модуль Order может хранить краткую информацию о пользователях сделавших заказ. И что бы не вызывать каждый раз API модуля User. 
Подписаться на соответствующие события модуля User (UserUpdate, UserCreate и т.д) и обновлять эти данные у себя.

## Common
В директории Common находятся код необходимый многим модулям: Взаимодействие с очередью, слушатели событий, гидратор, функционал работы статусов сущностей и т. д.
